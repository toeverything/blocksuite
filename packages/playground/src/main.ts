/// <reference types="./env" />
import '@blocksuite/blocks';
import '@blocksuite/editor';
import './components/start-panel';
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import '@blocksuite/editor/themes/affine.css';

import { ContentParser } from '@blocksuite/blocks/content-parser';
import { __unstableSchemas, AffineSchemas } from '@blocksuite/blocks/models';
import std from '@blocksuite/blocks/std';
import type { DocProvider, Page } from '@blocksuite/store';
import { Workspace } from '@blocksuite/store';
import type { SubdocEvent } from '@blocksuite/store/yjs';
import type * as Y from 'yjs';

import { DebugMenu } from './components/debug-menu.js';
import type { InitFn } from './data';
import {
  createEditor,
  createWorkspaceOptions,
  defaultMode,
  initDebugConfig,
  initParam,
  isE2E,
  tryInitExternalContent,
} from './utils.js';

const options = createWorkspaceOptions();
initDebugConfig();

// Subscribe for page update and create editor after page loaded.
function subscribePage(workspace: Workspace) {
  workspace.slots.pageAdded.once(pageId => {
    if (typeof globalThis.targetPageId === 'string') {
      if (pageId !== globalThis.targetPageId) {
        // if there's `targetPageId` which not same as the `pageId`
        return;
      }
    }
    const app = document.getElementById('app');
    if (!app) {
      return;
    }
    const page = workspace.getPage(pageId) as Page;

    const editor = createEditor(page, app);
    const contentParser = new ContentParser(page);
    const debugMenu = new DebugMenu();
    debugMenu.workspace = workspace;
    debugMenu.editor = editor;
    debugMenu.mode = defaultMode;
    debugMenu.contentParser = contentParser;
    document.body.appendChild(debugMenu);

    window.editor = editor;
    window.page = page;
  });
}

export async function initPageContentByParam(
  workspace: Workspace,
  param: string,
  pageId: string
) {
  const functionMap = new Map<
    string,
    (workspace: Workspace, id: string) => void
  >();
  Object.values(
    (await import('./data/index.js')) as Record<string, InitFn>
  ).forEach(fn => functionMap.set(fn.id, fn));
  // Load the preset playground documentation when `?init` param provided
  if (param === '') {
    param = 'preset';
  }

  // Load built-in init function when `?init=heavy` param provided
  if (functionMap.has(param)) {
    functionMap.get(param)?.(workspace, pageId);
    const page = workspace.getPage(pageId);
    await page?.waitForLoaded();
    page?.resetHistory();
    return;
  }

  // Try to load base64 content or markdown content from url
  await tryInitExternalContent(workspace, param, pageId);
}

export function storeSubdocProviders(workspace: Workspace) {
  const subdocProvidersMap = new Map<string, DocProvider[]>();
  const params = new URLSearchParams(location.search);
  const providerArgs = params.get('providers');

  // indexeddb provider has already supported subdoc
  if (providerArgs === 'indexeddb') {
    return subdocProvidersMap;
  }
  workspace.doc.on('subdocs', ({ loaded }: SubdocEvent) => {
    const findSpaceByDoc = (doc: Y.Doc) => {
      return Array.from(workspace.pages.values()).find(space => {
        return space.spaceDoc.guid === doc.guid;
      });
    };

    loaded.forEach(subdoc => {
      const space = findSpaceByDoc(subdoc);
      if (!space) {
        return;
      }

      const subdocProviders = (options.providerCreators || []).map(creator => {
        return creator(subdoc.guid, subdoc, {
          awareness: workspace.awarenessStore.awareness,
        });
      });

      subdocProvidersMap.set(space.prefixedId, subdocProviders);
    });
  });
  return subdocProvidersMap;
}

async function main() {
  if (window.workspace) {
    return;
  }
  const workspace = new Workspace(options)
    .register(AffineSchemas)
    .register(__unstableSchemas);
  window.workspace = workspace;
  window.blockSchemas = AffineSchemas;
  window.Y = Workspace.Y;
  window.std = std;
  window.ContentParser = ContentParser;
  window.subdocProviders = storeSubdocProviders(workspace);

  const syncProviders = async (providers: DocProvider[]) => {
    for (const provider of providers) {
      if ('active' in provider) {
        provider.sync();
        await provider.whenReady;
      } else if ('passive' in provider) {
        provider.connect();
      }
    }
  };

  await syncProviders(workspace.providers);
  await syncProviders(Array.from(window.subdocProviders.values()).flat());

  workspace.slots.pageAdded.on(async pageId => {
    const page = workspace.getPage(pageId) as Page;
    await page.waitForLoaded();
    const subdocProviders = window.subdocProviders.get(`space:${pageId}`);
    if (subdocProviders) {
      await syncProviders(subdocProviders);
    }
  });

  // In E2E environment, initial state should be generated by test case,
  // instead of using this default setup.
  if (isE2E) return;

  subscribePage(workspace);
  if (initParam !== null) {
    await initPageContentByParam(workspace, initParam, 'page0');
    return;
  }

  // Open default examples list when no `?init` param is provided
  const exampleList = document.createElement('start-panel');
  workspace.slots.pageAdded.once(() => exampleList.remove());
  document.body.prepend(exampleList);
}

main();
